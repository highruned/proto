// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/storage/storage.proto

#ifndef PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED
#define PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
#include "lib/protocol/descriptor.pb.h"
#include "lib/protocol/entity.pb.h"
#include "lib/rpc/rpc.pb.h"
// @@protoc_insertion_point(includes)

namespace bnet {
namespace protocol {
namespace storage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

class TableId;
class ColumnId;
class RowId;
class Privilege;
class ScanOperation;
class Command;
class Operation;
class Cell;
class OperationResult;
class OpenTableRequest;
class OpenTableResponse;
class OpenColumnRequest;
class OpenColumnResponse;
class ExecuteRequest;
class ExecuteResponse;

enum Privilege_Permission {
  Privilege_Permission_OWNER = 1,
  Privilege_Permission_FRIEND = 2,
  Privilege_Permission_OTHER = 4,
  Privilege_Permission_GAME = 8,
  Privilege_Permission_ALL = 15
};
bool Privilege_Permission_IsValid(int value);
const Privilege_Permission Privilege_Permission_Permission_MIN = Privilege_Permission_OWNER;
const Privilege_Permission Privilege_Permission_Permission_MAX = Privilege_Permission_ALL;
const int Privilege_Permission_Permission_ARRAYSIZE = Privilege_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* Privilege_Permission_descriptor();
inline const ::std::string& Privilege_Permission_Name(Privilege_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    Privilege_Permission_descriptor(), value);
}
inline bool Privilege_Permission_Parse(
    const ::std::string& name, Privilege_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Privilege_Permission>(
    Privilege_Permission_descriptor(), name, value);
}
enum ScanOperation_Op {
  ScanOperation_Op_IS_CLEAR = 1,
  ScanOperation_Op_NOT_CLEAR = 2,
  ScanOperation_Op_IS_EQUALS = 3,
  ScanOperation_Op_NOT_EQUALS = 4,
  ScanOperation_Op_IS_GREATER_THAN = 5,
  ScanOperation_Op_NOT_GREATER_THAN = 6,
  ScanOperation_Op_IS_LESS_THAN = 7,
  ScanOperation_Op_NOT_LESS_THAN = 8
};
bool ScanOperation_Op_IsValid(int value);
const ScanOperation_Op ScanOperation_Op_Op_MIN = ScanOperation_Op_IS_CLEAR;
const ScanOperation_Op ScanOperation_Op_Op_MAX = ScanOperation_Op_NOT_LESS_THAN;
const int ScanOperation_Op_Op_ARRAYSIZE = ScanOperation_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScanOperation_Op_descriptor();
inline const ::std::string& ScanOperation_Op_Name(ScanOperation_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScanOperation_Op_descriptor(), value);
}
inline bool ScanOperation_Op_Parse(
    const ::std::string& name, ScanOperation_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScanOperation_Op>(
    ScanOperation_Op_descriptor(), name, value);
}
enum Command_Op {
  Command_Op_ROW_DELETE = 1,
  Command_Op_ROW_FETCH = 2,
  Command_Op_COL_DELETE = 3,
  Command_Op_COL_FETCH = 4,
  Command_Op_COL_WRITE = 5,
  Command_Op_COL_MERGE = 6,
  Command_Op_FLD_CLEAR = 7,
  Command_Op_FLD_FETCH = 8,
  Command_Op_FLD_WRITE = 9,
  Command_Op_FLD_MERGE = 10,
  Command_Op_FLD_INCR = 11,
  Command_Op_FLD_TEST = 12,
  Command_Op_FLD_SCAN = 13,
  Command_Op_ROW_TEST = 14,
  Command_Op_COL_TEST = 15,
  Command_Op_FLD_SMAX = 16,
  Command_Op_COL_COND = 17,
  Command_Op_FLD_COND = 18,
  Command_Op_COND_POP = 19,
  Command_Op_LOG_DEBUG = 20
};
bool Command_Op_IsValid(int value);
const Command_Op Command_Op_Op_MIN = Command_Op_ROW_DELETE;
const Command_Op Command_Op_Op_MAX = Command_Op_LOG_DEBUG;
const int Command_Op_Op_ARRAYSIZE = Command_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Op_descriptor();
inline const ::std::string& Command_Op_Name(Command_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Op_descriptor(), value);
}
inline bool Command_Op_Parse(
    const ::std::string& name, Command_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Op>(
    Command_Op_descriptor(), name, value);
}
enum Command_Cond {
  Command_Cond_COND_ALWAYS = 0,
  Command_Cond_COND_NOT_EXISTS = 1,
  Command_Cond_COND_NOT_EQUAL = 2,
  Command_Cond_COND_LESS_THAN = 3,
  Command_Cond_COND_NOT_GREATER = 4,
  Command_Cond_COND_EQUALS = 5,
  Command_Cond_COND_NOT_LESS = 6,
  Command_Cond_COND_GREATER_THAN = 7,
  Command_Cond_COND_NEVER = 8
};
bool Command_Cond_IsValid(int value);
const Command_Cond Command_Cond_Cond_MIN = Command_Cond_COND_ALWAYS;
const Command_Cond Command_Cond_Cond_MAX = Command_Cond_COND_NEVER;
const int Command_Cond_Cond_ARRAYSIZE = Command_Cond_Cond_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Cond_descriptor();
inline const ::std::string& Command_Cond_Name(Command_Cond value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Cond_descriptor(), value);
}
inline bool Command_Cond_Parse(
    const ::std::string& name, Command_Cond* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Cond>(
    Command_Cond_descriptor(), name, value);
}
// ===================================================================

class TableId : public ::google::protobuf::Message {
 public:
  TableId();
  virtual ~TableId();
  
  TableId(const TableId& from);
  
  inline TableId& operator=(const TableId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableId& default_instance();
  
  void Swap(TableId* other);
  
  // implements Message ----------------------------------------------
  
  TableId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableId& from);
  void MergeFrom(const TableId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.TableId)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TableId* default_instance_;
};
// -------------------------------------------------------------------

class ColumnId : public ::google::protobuf::Message {
 public:
  ColumnId();
  virtual ~ColumnId();
  
  ColumnId(const ColumnId& from);
  
  inline ColumnId& operator=(const ColumnId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnId& default_instance();
  
  void Swap(ColumnId* other);
  
  // implements Message ----------------------------------------------
  
  ColumnId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnId& from);
  void MergeFrom(const ColumnId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.ColumnId)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ColumnId* default_instance_;
};
// -------------------------------------------------------------------

class RowId : public ::google::protobuf::Message {
 public:
  RowId();
  virtual ~RowId();
  
  RowId(const RowId& from);
  
  inline RowId& operator=(const RowId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RowId& default_instance();
  
  void Swap(RowId* other);
  
  // implements Message ----------------------------------------------
  
  RowId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RowId& from);
  void MergeFrom(const RowId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.RowId)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RowId* default_instance_;
};
// -------------------------------------------------------------------

class Privilege : public ::google::protobuf::Message {
 public:
  Privilege();
  virtual ~Privilege();
  
  Privilege(const Privilege& from);
  
  inline Privilege& operator=(const Privilege& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Privilege& default_instance();
  
  void Swap(Privilege* other);
  
  // implements Message ----------------------------------------------
  
  Privilege* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Privilege& from);
  void MergeFrom(const Privilege& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Privilege_Permission Permission;
  static const Permission OWNER = Privilege_Permission_OWNER;
  static const Permission FRIEND = Privilege_Permission_FRIEND;
  static const Permission OTHER = Privilege_Permission_OTHER;
  static const Permission GAME = Privilege_Permission_GAME;
  static const Permission ALL = Privilege_Permission_ALL;
  static inline bool Permission_IsValid(int value) {
    return Privilege_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    Privilege_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    Privilege_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    Privilege_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return Privilege_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return Privilege_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return Privilege_Permission_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 bits = 1 [default = 0];
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 1;
  inline ::google::protobuf::uint64 bits() const;
  inline void set_bits(::google::protobuf::uint64 value);
  
  // optional fixed32 program = 2 [default = 0];
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 2;
  inline ::google::protobuf::uint32 program() const;
  inline void set_program(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.Privilege)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 bits_;
  ::google::protobuf::uint32 program_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Privilege* default_instance_;
};
// -------------------------------------------------------------------

class ScanOperation : public ::google::protobuf::Message {
 public:
  ScanOperation();
  virtual ~ScanOperation();
  
  ScanOperation(const ScanOperation& from);
  
  inline ScanOperation& operator=(const ScanOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanOperation& default_instance();
  
  void Swap(ScanOperation* other);
  
  // implements Message ----------------------------------------------
  
  ScanOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanOperation& from);
  void MergeFrom(const ScanOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ScanOperation_Op Op;
  static const Op IS_CLEAR = ScanOperation_Op_IS_CLEAR;
  static const Op NOT_CLEAR = ScanOperation_Op_NOT_CLEAR;
  static const Op IS_EQUALS = ScanOperation_Op_IS_EQUALS;
  static const Op NOT_EQUALS = ScanOperation_Op_NOT_EQUALS;
  static const Op IS_GREATER_THAN = ScanOperation_Op_IS_GREATER_THAN;
  static const Op NOT_GREATER_THAN = ScanOperation_Op_NOT_GREATER_THAN;
  static const Op IS_LESS_THAN = ScanOperation_Op_IS_LESS_THAN;
  static const Op NOT_LESS_THAN = ScanOperation_Op_NOT_LESS_THAN;
  static inline bool Op_IsValid(int value) {
    return ScanOperation_Op_IsValid(value);
  }
  static const Op Op_MIN =
    ScanOperation_Op_Op_MIN;
  static const Op Op_MAX =
    ScanOperation_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    ScanOperation_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return ScanOperation_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return ScanOperation_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return ScanOperation_Op_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.storage.ScanOperation.Op op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::bnet::protocol::storage::ScanOperation_Op op() const;
  inline void set_op(::bnet::protocol::storage::ScanOperation_Op value);
  
  // required .bnet.protocol.Path field = 2;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::bnet::protocol::Path& field() const;
  inline ::bnet::protocol::Path* mutable_field();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.ScanOperation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int op_;
  ::bnet::protocol::Path* field_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ScanOperation* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Command_Op Op;
  static const Op ROW_DELETE = Command_Op_ROW_DELETE;
  static const Op ROW_FETCH = Command_Op_ROW_FETCH;
  static const Op COL_DELETE = Command_Op_COL_DELETE;
  static const Op COL_FETCH = Command_Op_COL_FETCH;
  static const Op COL_WRITE = Command_Op_COL_WRITE;
  static const Op COL_MERGE = Command_Op_COL_MERGE;
  static const Op FLD_CLEAR = Command_Op_FLD_CLEAR;
  static const Op FLD_FETCH = Command_Op_FLD_FETCH;
  static const Op FLD_WRITE = Command_Op_FLD_WRITE;
  static const Op FLD_MERGE = Command_Op_FLD_MERGE;
  static const Op FLD_INCR = Command_Op_FLD_INCR;
  static const Op FLD_TEST = Command_Op_FLD_TEST;
  static const Op FLD_SCAN = Command_Op_FLD_SCAN;
  static const Op ROW_TEST = Command_Op_ROW_TEST;
  static const Op COL_TEST = Command_Op_COL_TEST;
  static const Op FLD_SMAX = Command_Op_FLD_SMAX;
  static const Op COL_COND = Command_Op_COL_COND;
  static const Op FLD_COND = Command_Op_FLD_COND;
  static const Op COND_POP = Command_Op_COND_POP;
  static const Op LOG_DEBUG = Command_Op_LOG_DEBUG;
  static inline bool Op_IsValid(int value) {
    return Command_Op_IsValid(value);
  }
  static const Op Op_MIN =
    Command_Op_Op_MIN;
  static const Op Op_MAX =
    Command_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    Command_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return Command_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return Command_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return Command_Op_Parse(name, value);
  }
  
  typedef Command_Cond Cond;
  static const Cond COND_ALWAYS = Command_Cond_COND_ALWAYS;
  static const Cond COND_NOT_EXISTS = Command_Cond_COND_NOT_EXISTS;
  static const Cond COND_NOT_EQUAL = Command_Cond_COND_NOT_EQUAL;
  static const Cond COND_LESS_THAN = Command_Cond_COND_LESS_THAN;
  static const Cond COND_NOT_GREATER = Command_Cond_COND_NOT_GREATER;
  static const Cond COND_EQUALS = Command_Cond_COND_EQUALS;
  static const Cond COND_NOT_LESS = Command_Cond_COND_NOT_LESS;
  static const Cond COND_GREATER_THAN = Command_Cond_COND_GREATER_THAN;
  static const Cond COND_NEVER = Command_Cond_COND_NEVER;
  static inline bool Cond_IsValid(int value) {
    return Command_Cond_IsValid(value);
  }
  static const Cond Cond_MIN =
    Command_Cond_Cond_MIN;
  static const Cond Cond_MAX =
    Command_Cond_Cond_MAX;
  static const int Cond_ARRAYSIZE =
    Command_Cond_Cond_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Cond_descriptor() {
    return Command_Cond_descriptor();
  }
  static inline const ::std::string& Cond_Name(Cond value) {
    return Command_Cond_Name(value);
  }
  static inline bool Cond_Parse(const ::std::string& name,
      Cond* value) {
    return Command_Cond_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.storage.Command.Op op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::bnet::protocol::storage::Command_Op op() const;
  inline void set_op(::bnet::protocol::storage::Command_Op value);
  
  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // repeated .bnet.protocol.Path fields = 3;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 3;
  inline const ::bnet::protocol::Path& fields(int index) const;
  inline ::bnet::protocol::Path* mutable_fields(int index);
  inline ::bnet::protocol::Path* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::Path >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::Path >*
      mutable_fields();
  
  // optional fixed64 min_version = 4;
  inline bool has_min_version() const;
  inline void clear_min_version();
  static const int kMinVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 min_version() const;
  inline void set_min_version(::google::protobuf::uint64 value);
  
  // optional fixed64 max_version = 5;
  inline bool has_max_version() const;
  inline void clear_max_version();
  static const int kMaxVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 max_version() const;
  inline void set_max_version(::google::protobuf::uint64 value);
  
  // optional .bnet.protocol.storage.ScanOperation scan = 6;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 6;
  inline const ::bnet::protocol::storage::ScanOperation& scan() const;
  inline ::bnet::protocol::storage::ScanOperation* mutable_scan();
  
  // optional uint32 limit = 7;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 7;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);
  
  // optional .bnet.protocol.storage.Command.Cond condition = 8;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 8;
  inline ::bnet::protocol::storage::Command_Cond condition() const;
  inline void set_condition(::bnet::protocol::storage::Command_Cond value);
  
  // optional string message = 11;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 11;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.Command)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int op_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::Path > fields_;
  ::google::protobuf::uint64 min_version_;
  ::google::protobuf::uint64 max_version_;
  ::bnet::protocol::storage::ScanOperation* scan_;
  ::google::protobuf::uint32 limit_;
  int condition_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message {
 public:
  Operation();
  virtual ~Operation();
  
  Operation(const Operation& from);
  
  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();
  
  void Swap(Operation* other);
  
  // implements Message ----------------------------------------------
  
  Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.storage.TableId table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::bnet::protocol::storage::TableId& table_id() const;
  inline ::bnet::protocol::storage::TableId* mutable_table_id();
  
  // optional .bnet.protocol.storage.ColumnId column_id = 2;
  inline bool has_column_id() const;
  inline void clear_column_id();
  static const int kColumnIdFieldNumber = 2;
  inline const ::bnet::protocol::storage::ColumnId& column_id() const;
  inline ::bnet::protocol::storage::ColumnId* mutable_column_id();
  
  // optional .bnet.protocol.storage.RowId row_id = 3;
  inline bool has_row_id() const;
  inline void clear_row_id();
  static const int kRowIdFieldNumber = 3;
  inline const ::bnet::protocol::storage::RowId& row_id() const;
  inline ::bnet::protocol::storage::RowId* mutable_row_id();
  
  // optional bytes row_key = 4;
  inline bool has_row_key() const;
  inline void clear_row_key();
  static const int kRowKeyFieldNumber = 4;
  inline const ::std::string& row_key() const;
  inline void set_row_key(const ::std::string& value);
  inline void set_row_key(const char* value);
  inline void set_row_key(const void* value, size_t size);
  inline ::std::string* mutable_row_key();
  
  // optional fixed64 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);
  
  // repeated .bnet.protocol.storage.Command rops = 6;
  inline int rops_size() const;
  inline void clear_rops();
  static const int kRopsFieldNumber = 6;
  inline const ::bnet::protocol::storage::Command& rops(int index) const;
  inline ::bnet::protocol::storage::Command* mutable_rops(int index);
  inline ::bnet::protocol::storage::Command* add_rops();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Command >&
      rops() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Command >*
      mutable_rops();
  
  // optional fixed64 mutate_version = 7;
  inline bool has_mutate_version() const;
  inline void clear_mutate_version();
  static const int kMutateVersionFieldNumber = 7;
  inline ::google::protobuf::uint64 mutate_version() const;
  inline void set_mutate_version(::google::protobuf::uint64 value);
  
  // optional .bnet.protocol.storage.Privilege privilege = 8;
  inline bool has_privilege() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 8;
  inline const ::bnet::protocol::storage::Privilege& privilege() const;
  inline ::bnet::protocol::storage::Privilege* mutable_privilege();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.Operation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bnet::protocol::storage::TableId* table_id_;
  ::bnet::protocol::storage::ColumnId* column_id_;
  ::bnet::protocol::storage::RowId* row_id_;
  ::std::string* row_key_;
  static const ::std::string _default_row_key_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Command > rops_;
  ::google::protobuf::uint64 mutate_version_;
  ::bnet::protocol::storage::Privilege* privilege_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Operation* default_instance_;
};
// -------------------------------------------------------------------

class Cell : public ::google::protobuf::Message {
 public:
  Cell();
  virtual ~Cell();
  
  Cell(const Cell& from);
  
  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell& default_instance();
  
  void Swap(Cell* other);
  
  // implements Message ----------------------------------------------
  
  Cell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.storage.ColumnId column_id = 1;
  inline bool has_column_id() const;
  inline void clear_column_id();
  static const int kColumnIdFieldNumber = 1;
  inline const ::bnet::protocol::storage::ColumnId& column_id() const;
  inline ::bnet::protocol::storage::ColumnId* mutable_column_id();
  
  // required .bnet.protocol.storage.RowId row_id = 2;
  inline bool has_row_id() const;
  inline void clear_row_id();
  static const int kRowIdFieldNumber = 2;
  inline const ::bnet::protocol::storage::RowId& row_id() const;
  inline ::bnet::protocol::storage::RowId* mutable_row_id();
  
  // optional bytes row_key = 3;
  inline bool has_row_key() const;
  inline void clear_row_key();
  static const int kRowKeyFieldNumber = 3;
  inline const ::std::string& row_key() const;
  inline void set_row_key(const ::std::string& value);
  inline void set_row_key(const char* value);
  inline void set_row_key(const void* value, size_t size);
  inline ::std::string* mutable_row_key();
  
  // optional fixed64 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);
  
  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.Cell)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bnet::protocol::storage::ColumnId* column_id_;
  ::bnet::protocol::storage::RowId* row_id_;
  ::std::string* row_key_;
  static const ::std::string _default_row_key_;
  ::google::protobuf::uint64 version_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Cell* default_instance_;
};
// -------------------------------------------------------------------

class OperationResult : public ::google::protobuf::Message {
 public:
  OperationResult();
  virtual ~OperationResult();
  
  OperationResult(const OperationResult& from);
  
  inline OperationResult& operator=(const OperationResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationResult& default_instance();
  
  void Swap(OperationResult* other);
  
  // implements Message ----------------------------------------------
  
  OperationResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationResult& from);
  void MergeFrom(const OperationResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 error_code = 1 [default = 0];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);
  
  // required .bnet.protocol.storage.TableId table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline const ::bnet::protocol::storage::TableId& table_id() const;
  inline ::bnet::protocol::storage::TableId* mutable_table_id();
  
  // repeated .bnet.protocol.storage.Cell data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::bnet::protocol::storage::Cell& data(int index) const;
  inline ::bnet::protocol::storage::Cell* mutable_data(int index);
  inline ::bnet::protocol::storage::Cell* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Cell >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Cell >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.OperationResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 error_code_;
  ::bnet::protocol::storage::TableId* table_id_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Cell > data_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OperationResult* default_instance_;
};
// -------------------------------------------------------------------

class OpenTableRequest : public ::google::protobuf::Message {
 public:
  OpenTableRequest();
  virtual ~OpenTableRequest();
  
  OpenTableRequest(const OpenTableRequest& from);
  
  inline OpenTableRequest& operator=(const OpenTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenTableRequest& default_instance();
  
  void Swap(OpenTableRequest* other);
  
  // implements Message ----------------------------------------------
  
  OpenTableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenTableRequest& from);
  void MergeFrom(const OpenTableRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string schema = 1 [default = "DEFAULT"];
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const char* value, size_t size);
  inline ::std::string* mutable_schema();
  
  // optional .bnet.protocol.storage.Privilege privilege = 2;
  inline bool has_privilege() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 2;
  inline const ::bnet::protocol::storage::Privilege& privilege() const;
  inline ::bnet::protocol::storage::Privilege* mutable_privilege();
  
  // required .bnet.protocol.storage.TableId table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline const ::bnet::protocol::storage::TableId& table_id() const;
  inline ::bnet::protocol::storage::TableId* mutable_table_id();
  
  // optional .bnet.protocol.EntityId agent_id = 4;
  inline bool has_agent_id() const;
  inline void clear_agent_id();
  static const int kAgentIdFieldNumber = 4;
  inline const ::bnet::protocol::EntityId& agent_id() const;
  inline ::bnet::protocol::EntityId* mutable_agent_id();
  
  // optional string process_name = 5;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 5;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.OpenTableRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* schema_;
  static const ::std::string _default_schema_;
  ::bnet::protocol::storage::Privilege* privilege_;
  ::bnet::protocol::storage::TableId* table_id_;
  ::bnet::protocol::EntityId* agent_id_;
  ::std::string* process_name_;
  static const ::std::string _default_process_name_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenTableRequest* default_instance_;
};
// -------------------------------------------------------------------

class OpenTableResponse : public ::google::protobuf::Message {
 public:
  OpenTableResponse();
  virtual ~OpenTableResponse();
  
  OpenTableResponse(const OpenTableResponse& from);
  
  inline OpenTableResponse& operator=(const OpenTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenTableResponse& default_instance();
  
  void Swap(OpenTableResponse* other);
  
  // implements Message ----------------------------------------------
  
  OpenTableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenTableResponse& from);
  void MergeFrom(const OpenTableResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.OpenTableResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenTableResponse* default_instance_;
};
// -------------------------------------------------------------------

class OpenColumnRequest : public ::google::protobuf::Message {
 public:
  OpenColumnRequest();
  virtual ~OpenColumnRequest();
  
  OpenColumnRequest(const OpenColumnRequest& from);
  
  inline OpenColumnRequest& operator=(const OpenColumnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenColumnRequest& default_instance();
  
  void Swap(OpenColumnRequest* other);
  
  // implements Message ----------------------------------------------
  
  OpenColumnRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenColumnRequest& from);
  void MergeFrom(const OpenColumnRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string schema = 1 [default = "DEFAULT"];
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const char* value, size_t size);
  inline ::std::string* mutable_schema();
  
  // optional .bnet.protocol.storage.Privilege privilege = 2;
  inline bool has_privilege() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 2;
  inline const ::bnet::protocol::storage::Privilege& privilege() const;
  inline ::bnet::protocol::storage::Privilege* mutable_privilege();
  
  // required .bnet.protocol.storage.TableId table_id = 4;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  inline const ::bnet::protocol::storage::TableId& table_id() const;
  inline ::bnet::protocol::storage::TableId* mutable_table_id();
  
  // required .bnet.protocol.storage.ColumnId column_id = 5;
  inline bool has_column_id() const;
  inline void clear_column_id();
  static const int kColumnIdFieldNumber = 5;
  inline const ::bnet::protocol::storage::ColumnId& column_id() const;
  inline ::bnet::protocol::storage::ColumnId* mutable_column_id();
  
  // optional string proto_type = 6;
  inline bool has_proto_type() const;
  inline void clear_proto_type();
  static const int kProtoTypeFieldNumber = 6;
  inline const ::std::string& proto_type() const;
  inline void set_proto_type(const ::std::string& value);
  inline void set_proto_type(const char* value);
  inline void set_proto_type(const char* value, size_t size);
  inline ::std::string* mutable_proto_type();
  
  // optional .bnet.protocol.EntityId agent_id = 7;
  inline bool has_agent_id() const;
  inline void clear_agent_id();
  static const int kAgentIdFieldNumber = 7;
  inline const ::bnet::protocol::EntityId& agent_id() const;
  inline ::bnet::protocol::EntityId* mutable_agent_id();
  
  // optional string process_name = 8;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 8;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.OpenColumnRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* schema_;
  static const ::std::string _default_schema_;
  ::bnet::protocol::storage::Privilege* privilege_;
  ::bnet::protocol::storage::TableId* table_id_;
  ::bnet::protocol::storage::ColumnId* column_id_;
  ::std::string* proto_type_;
  static const ::std::string _default_proto_type_;
  ::bnet::protocol::EntityId* agent_id_;
  ::std::string* process_name_;
  static const ::std::string _default_process_name_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenColumnRequest* default_instance_;
};
// -------------------------------------------------------------------

class OpenColumnResponse : public ::google::protobuf::Message {
 public:
  OpenColumnResponse();
  virtual ~OpenColumnResponse();
  
  OpenColumnResponse(const OpenColumnResponse& from);
  
  inline OpenColumnResponse& operator=(const OpenColumnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenColumnResponse& default_instance();
  
  void Swap(OpenColumnResponse* other);
  
  // implements Message ----------------------------------------------
  
  OpenColumnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenColumnResponse& from);
  void MergeFrom(const OpenColumnResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool server_field_ops = 2 [default = false];
  inline bool has_server_field_ops() const;
  inline void clear_server_field_ops();
  static const int kServerFieldOpsFieldNumber = 2;
  inline bool server_field_ops() const;
  inline void set_server_field_ops(bool value);
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.OpenColumnResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool server_field_ops_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenColumnResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteRequest : public ::google::protobuf::Message {
 public:
  ExecuteRequest();
  virtual ~ExecuteRequest();
  
  ExecuteRequest(const ExecuteRequest& from);
  
  inline ExecuteRequest& operator=(const ExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteRequest& default_instance();
  
  void Swap(ExecuteRequest* other);
  
  // implements Message ----------------------------------------------
  
  ExecuteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteRequest& from);
  void MergeFrom(const ExecuteRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string schema = 1 [default = "DEFAULT"];
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::std::string& schema() const;
  inline void set_schema(const ::std::string& value);
  inline void set_schema(const char* value);
  inline void set_schema(const char* value, size_t size);
  inline ::std::string* mutable_schema();
  
  // optional .bnet.protocol.storage.Privilege privilege = 2;
  inline bool has_privilege() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 2;
  inline const ::bnet::protocol::storage::Privilege& privilege() const;
  inline ::bnet::protocol::storage::Privilege* mutable_privilege();
  
  // optional bool read_only = 3 [default = false];
  inline bool has_read_only() const;
  inline void clear_read_only();
  static const int kReadOnlyFieldNumber = 3;
  inline bool read_only() const;
  inline void set_read_only(bool value);
  
  // optional bool wants_row_key = 4 [default = false];
  inline bool has_wants_row_key() const;
  inline void clear_wants_row_key();
  static const int kWantsRowKeyFieldNumber = 4;
  inline bool wants_row_key() const;
  inline void set_wants_row_key(bool value);
  
  // optional bool wants_column_name = 5 [default = false];
  inline bool has_wants_column_name() const;
  inline void clear_wants_column_name();
  static const int kWantsColumnNameFieldNumber = 5;
  inline bool wants_column_name() const;
  inline void set_wants_column_name(bool value);
  
  // optional uint32 max_data_size = 6 [default = 16777215];
  inline bool has_max_data_size() const;
  inline void clear_max_data_size();
  static const int kMaxDataSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 max_data_size() const;
  inline void set_max_data_size(::google::protobuf::uint32 value);
  
  // repeated .bnet.protocol.storage.Operation operations = 7;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 7;
  inline const ::bnet::protocol::storage::Operation& operations(int index) const;
  inline ::bnet::protocol::storage::Operation* mutable_operations(int index);
  inline ::bnet::protocol::storage::Operation* add_operations();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Operation >&
      operations() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Operation >*
      mutable_operations();
  
  // optional uint32 timeout = 12;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 12;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);
  
  // optional .bnet.protocol.EntityId agent_id = 9;
  inline bool has_agent_id() const;
  inline void clear_agent_id();
  static const int kAgentIdFieldNumber = 9;
  inline const ::bnet::protocol::EntityId& agent_id() const;
  inline ::bnet::protocol::EntityId* mutable_agent_id();
  
  // optional string query_name = 10 [default = "NoName"];
  inline bool has_query_name() const;
  inline void clear_query_name();
  static const int kQueryNameFieldNumber = 10;
  inline const ::std::string& query_name() const;
  inline void set_query_name(const ::std::string& value);
  inline void set_query_name(const char* value);
  inline void set_query_name(const char* value, size_t size);
  inline ::std::string* mutable_query_name();
  
  // optional string process_name = 11;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 11;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.ExecuteRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* schema_;
  static const ::std::string _default_schema_;
  ::bnet::protocol::storage::Privilege* privilege_;
  bool read_only_;
  bool wants_row_key_;
  bool wants_column_name_;
  ::google::protobuf::uint32 max_data_size_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Operation > operations_;
  ::google::protobuf::uint32 timeout_;
  ::bnet::protocol::EntityId* agent_id_;
  ::std::string* query_name_;
  static const ::std::string _default_query_name_;
  ::std::string* process_name_;
  static const ::std::string _default_process_name_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecuteRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteResponse : public ::google::protobuf::Message {
 public:
  ExecuteResponse();
  virtual ~ExecuteResponse();
  
  ExecuteResponse(const ExecuteResponse& from);
  
  inline ExecuteResponse& operator=(const ExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteResponse& default_instance();
  
  void Swap(ExecuteResponse* other);
  
  // implements Message ----------------------------------------------
  
  ExecuteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteResponse& from);
  void MergeFrom(const ExecuteResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 error_code = 1 [default = 0];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);
  
  // repeated .bnet.protocol.storage.OperationResult results = 2;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 2;
  inline const ::bnet::protocol::storage::OperationResult& results(int index) const;
  inline ::bnet::protocol::storage::OperationResult* mutable_results(int index);
  inline ::bnet::protocol::storage::OperationResult* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::OperationResult >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::OperationResult >*
      mutable_results();
  
  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.storage.ExecuteResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 error_code_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::OperationResult > results_;
  ::std::string* error_message_;
  static const ::std::string _default_error_message_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecuteResponse* default_instance_;
};
// ===================================================================

class StorageService_Stub;

class StorageService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline StorageService() {};
 public:
  virtual ~StorageService();
  
  typedef StorageService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Execute(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::ExecuteRequest* request,
                       ::bnet::protocol::storage::ExecuteResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void OpenTable(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::OpenTableRequest* request,
                       ::bnet::protocol::storage::OpenTableResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void OpenColumn(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::OpenColumnRequest* request,
                       ::bnet::protocol::storage::OpenColumnResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StorageService);
};

class StorageService_Stub : public StorageService {
 public:
  StorageService_Stub(::google::protobuf::RpcChannel* channel);
  StorageService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~StorageService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements StorageService ------------------------------------------
  
  void Execute(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::ExecuteRequest* request,
                       ::bnet::protocol::storage::ExecuteResponse* response,
                       ::google::protobuf::Closure* done);
  void OpenTable(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::OpenTableRequest* request,
                       ::bnet::protocol::storage::OpenTableResponse* response,
                       ::google::protobuf::Closure* done);
  void OpenColumn(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::storage::OpenColumnRequest* request,
                       ::bnet::protocol::storage::OpenColumnResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StorageService_Stub);
};


// ===================================================================


// ===================================================================

// TableId

// required bytes hash = 1;
inline bool TableId::has_hash() const {
  return _has_bit(0);
}
inline void TableId::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TableId::hash() const {
  return *hash_;
}
inline void TableId::set_hash(const ::std::string& value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TableId::set_hash(const char* value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TableId::set_hash(const void* value, size_t size) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableId::mutable_hash() {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// -------------------------------------------------------------------

// ColumnId

// required bytes hash = 1;
inline bool ColumnId::has_hash() const {
  return _has_bit(0);
}
inline void ColumnId::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ColumnId::hash() const {
  return *hash_;
}
inline void ColumnId::set_hash(const ::std::string& value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ColumnId::set_hash(const char* value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ColumnId::set_hash(const void* value, size_t size) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ColumnId::mutable_hash() {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// -------------------------------------------------------------------

// RowId

// required bytes hash = 1;
inline bool RowId::has_hash() const {
  return _has_bit(0);
}
inline void RowId::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RowId::hash() const {
  return *hash_;
}
inline void RowId::set_hash(const ::std::string& value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void RowId::set_hash(const char* value) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void RowId::set_hash(const void* value, size_t size) {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RowId::mutable_hash() {
  _set_bit(0);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// -------------------------------------------------------------------

// Privilege

// optional fixed64 bits = 1 [default = 0];
inline bool Privilege::has_bits() const {
  return _has_bit(0);
}
inline void Privilege::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Privilege::bits() const {
  return bits_;
}
inline void Privilege::set_bits(::google::protobuf::uint64 value) {
  _set_bit(0);
  bits_ = value;
}

// optional fixed32 program = 2 [default = 0];
inline bool Privilege::has_program() const {
  return _has_bit(1);
}
inline void Privilege::clear_program() {
  program_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Privilege::program() const {
  return program_;
}
inline void Privilege::set_program(::google::protobuf::uint32 value) {
  _set_bit(1);
  program_ = value;
}

// -------------------------------------------------------------------

// ScanOperation

// required .bnet.protocol.storage.ScanOperation.Op op = 1;
inline bool ScanOperation::has_op() const {
  return _has_bit(0);
}
inline void ScanOperation::clear_op() {
  op_ = 1;
  _clear_bit(0);
}
inline ::bnet::protocol::storage::ScanOperation_Op ScanOperation::op() const {
  return static_cast< ::bnet::protocol::storage::ScanOperation_Op >(op_);
}
inline void ScanOperation::set_op(::bnet::protocol::storage::ScanOperation_Op value) {
  GOOGLE_DCHECK(::bnet::protocol::storage::ScanOperation_Op_IsValid(value));
  _set_bit(0);
  op_ = value;
}

// required .bnet.protocol.Path field = 2;
inline bool ScanOperation::has_field() const {
  return _has_bit(1);
}
inline void ScanOperation::clear_field() {
  if (field_ != NULL) field_->::bnet::protocol::Path::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::Path& ScanOperation::field() const {
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::bnet::protocol::Path* ScanOperation::mutable_field() {
  _set_bit(1);
  if (field_ == NULL) field_ = new ::bnet::protocol::Path;
  return field_;
}

// -------------------------------------------------------------------

// Command

// required .bnet.protocol.storage.Command.Op op = 1;
inline bool Command::has_op() const {
  return _has_bit(0);
}
inline void Command::clear_op() {
  op_ = 1;
  _clear_bit(0);
}
inline ::bnet::protocol::storage::Command_Op Command::op() const {
  return static_cast< ::bnet::protocol::storage::Command_Op >(op_);
}
inline void Command::set_op(::bnet::protocol::storage::Command_Op value) {
  GOOGLE_DCHECK(::bnet::protocol::storage::Command_Op_IsValid(value));
  _set_bit(0);
  op_ = value;
}

// optional bytes data = 2;
inline bool Command::has_data() const {
  return _has_bit(1);
}
inline void Command::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Command::data() const {
  return *data_;
}
inline void Command::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Command::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Command::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// repeated .bnet.protocol.Path fields = 3;
inline int Command::fields_size() const {
  return fields_.size();
}
inline void Command::clear_fields() {
  fields_.Clear();
}
inline const ::bnet::protocol::Path& Command::fields(int index) const {
  return fields_.Get(index);
}
inline ::bnet::protocol::Path* Command::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::bnet::protocol::Path* Command::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::Path >&
Command::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::Path >*
Command::mutable_fields() {
  return &fields_;
}

// optional fixed64 min_version = 4;
inline bool Command::has_min_version() const {
  return _has_bit(3);
}
inline void Command::clear_min_version() {
  min_version_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 Command::min_version() const {
  return min_version_;
}
inline void Command::set_min_version(::google::protobuf::uint64 value) {
  _set_bit(3);
  min_version_ = value;
}

// optional fixed64 max_version = 5;
inline bool Command::has_max_version() const {
  return _has_bit(4);
}
inline void Command::clear_max_version() {
  max_version_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 Command::max_version() const {
  return max_version_;
}
inline void Command::set_max_version(::google::protobuf::uint64 value) {
  _set_bit(4);
  max_version_ = value;
}

// optional .bnet.protocol.storage.ScanOperation scan = 6;
inline bool Command::has_scan() const {
  return _has_bit(5);
}
inline void Command::clear_scan() {
  if (scan_ != NULL) scan_->::bnet::protocol::storage::ScanOperation::Clear();
  _clear_bit(5);
}
inline const ::bnet::protocol::storage::ScanOperation& Command::scan() const {
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::bnet::protocol::storage::ScanOperation* Command::mutable_scan() {
  _set_bit(5);
  if (scan_ == NULL) scan_ = new ::bnet::protocol::storage::ScanOperation;
  return scan_;
}

// optional uint32 limit = 7;
inline bool Command::has_limit() const {
  return _has_bit(6);
}
inline void Command::clear_limit() {
  limit_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 Command::limit() const {
  return limit_;
}
inline void Command::set_limit(::google::protobuf::uint32 value) {
  _set_bit(6);
  limit_ = value;
}

// optional .bnet.protocol.storage.Command.Cond condition = 8;
inline bool Command::has_condition() const {
  return _has_bit(7);
}
inline void Command::clear_condition() {
  condition_ = 0;
  _clear_bit(7);
}
inline ::bnet::protocol::storage::Command_Cond Command::condition() const {
  return static_cast< ::bnet::protocol::storage::Command_Cond >(condition_);
}
inline void Command::set_condition(::bnet::protocol::storage::Command_Cond value) {
  GOOGLE_DCHECK(::bnet::protocol::storage::Command_Cond_IsValid(value));
  _set_bit(7);
  condition_ = value;
}

// optional string message = 11;
inline bool Command::has_message() const {
  return _has_bit(8);
}
inline void Command::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& Command::message() const {
  return *message_;
}
inline void Command::set_message(const ::std::string& value) {
  _set_bit(8);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Command::set_message(const char* value) {
  _set_bit(8);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Command::set_message(const char* value, size_t size) {
  _set_bit(8);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_message() {
  _set_bit(8);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// Operation

// required .bnet.protocol.storage.TableId table_id = 1;
inline bool Operation::has_table_id() const {
  return _has_bit(0);
}
inline void Operation::clear_table_id() {
  if (table_id_ != NULL) table_id_->::bnet::protocol::storage::TableId::Clear();
  _clear_bit(0);
}
inline const ::bnet::protocol::storage::TableId& Operation::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::bnet::protocol::storage::TableId* Operation::mutable_table_id() {
  _set_bit(0);
  if (table_id_ == NULL) table_id_ = new ::bnet::protocol::storage::TableId;
  return table_id_;
}

// optional .bnet.protocol.storage.ColumnId column_id = 2;
inline bool Operation::has_column_id() const {
  return _has_bit(1);
}
inline void Operation::clear_column_id() {
  if (column_id_ != NULL) column_id_->::bnet::protocol::storage::ColumnId::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::ColumnId& Operation::column_id() const {
  return column_id_ != NULL ? *column_id_ : *default_instance_->column_id_;
}
inline ::bnet::protocol::storage::ColumnId* Operation::mutable_column_id() {
  _set_bit(1);
  if (column_id_ == NULL) column_id_ = new ::bnet::protocol::storage::ColumnId;
  return column_id_;
}

// optional .bnet.protocol.storage.RowId row_id = 3;
inline bool Operation::has_row_id() const {
  return _has_bit(2);
}
inline void Operation::clear_row_id() {
  if (row_id_ != NULL) row_id_->::bnet::protocol::storage::RowId::Clear();
  _clear_bit(2);
}
inline const ::bnet::protocol::storage::RowId& Operation::row_id() const {
  return row_id_ != NULL ? *row_id_ : *default_instance_->row_id_;
}
inline ::bnet::protocol::storage::RowId* Operation::mutable_row_id() {
  _set_bit(2);
  if (row_id_ == NULL) row_id_ = new ::bnet::protocol::storage::RowId;
  return row_id_;
}

// optional bytes row_key = 4;
inline bool Operation::has_row_key() const {
  return _has_bit(3);
}
inline void Operation::clear_row_key() {
  if (row_key_ != &_default_row_key_) {
    row_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Operation::row_key() const {
  return *row_key_;
}
inline void Operation::set_row_key(const ::std::string& value) {
  _set_bit(3);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(value);
}
inline void Operation::set_row_key(const char* value) {
  _set_bit(3);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(value);
}
inline void Operation::set_row_key(const void* value, size_t size) {
  _set_bit(3);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Operation::mutable_row_key() {
  _set_bit(3);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  return row_key_;
}

// optional fixed64 version = 5;
inline bool Operation::has_version() const {
  return _has_bit(4);
}
inline void Operation::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 Operation::version() const {
  return version_;
}
inline void Operation::set_version(::google::protobuf::uint64 value) {
  _set_bit(4);
  version_ = value;
}

// repeated .bnet.protocol.storage.Command rops = 6;
inline int Operation::rops_size() const {
  return rops_.size();
}
inline void Operation::clear_rops() {
  rops_.Clear();
}
inline const ::bnet::protocol::storage::Command& Operation::rops(int index) const {
  return rops_.Get(index);
}
inline ::bnet::protocol::storage::Command* Operation::mutable_rops(int index) {
  return rops_.Mutable(index);
}
inline ::bnet::protocol::storage::Command* Operation::add_rops() {
  return rops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Command >&
Operation::rops() const {
  return rops_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Command >*
Operation::mutable_rops() {
  return &rops_;
}

// optional fixed64 mutate_version = 7;
inline bool Operation::has_mutate_version() const {
  return _has_bit(6);
}
inline void Operation::clear_mutate_version() {
  mutate_version_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 Operation::mutate_version() const {
  return mutate_version_;
}
inline void Operation::set_mutate_version(::google::protobuf::uint64 value) {
  _set_bit(6);
  mutate_version_ = value;
}

// optional .bnet.protocol.storage.Privilege privilege = 8;
inline bool Operation::has_privilege() const {
  return _has_bit(7);
}
inline void Operation::clear_privilege() {
  if (privilege_ != NULL) privilege_->::bnet::protocol::storage::Privilege::Clear();
  _clear_bit(7);
}
inline const ::bnet::protocol::storage::Privilege& Operation::privilege() const {
  return privilege_ != NULL ? *privilege_ : *default_instance_->privilege_;
}
inline ::bnet::protocol::storage::Privilege* Operation::mutable_privilege() {
  _set_bit(7);
  if (privilege_ == NULL) privilege_ = new ::bnet::protocol::storage::Privilege;
  return privilege_;
}

// -------------------------------------------------------------------

// Cell

// required .bnet.protocol.storage.ColumnId column_id = 1;
inline bool Cell::has_column_id() const {
  return _has_bit(0);
}
inline void Cell::clear_column_id() {
  if (column_id_ != NULL) column_id_->::bnet::protocol::storage::ColumnId::Clear();
  _clear_bit(0);
}
inline const ::bnet::protocol::storage::ColumnId& Cell::column_id() const {
  return column_id_ != NULL ? *column_id_ : *default_instance_->column_id_;
}
inline ::bnet::protocol::storage::ColumnId* Cell::mutable_column_id() {
  _set_bit(0);
  if (column_id_ == NULL) column_id_ = new ::bnet::protocol::storage::ColumnId;
  return column_id_;
}

// required .bnet.protocol.storage.RowId row_id = 2;
inline bool Cell::has_row_id() const {
  return _has_bit(1);
}
inline void Cell::clear_row_id() {
  if (row_id_ != NULL) row_id_->::bnet::protocol::storage::RowId::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::RowId& Cell::row_id() const {
  return row_id_ != NULL ? *row_id_ : *default_instance_->row_id_;
}
inline ::bnet::protocol::storage::RowId* Cell::mutable_row_id() {
  _set_bit(1);
  if (row_id_ == NULL) row_id_ = new ::bnet::protocol::storage::RowId;
  return row_id_;
}

// optional bytes row_key = 3;
inline bool Cell::has_row_key() const {
  return _has_bit(2);
}
inline void Cell::clear_row_key() {
  if (row_key_ != &_default_row_key_) {
    row_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Cell::row_key() const {
  return *row_key_;
}
inline void Cell::set_row_key(const ::std::string& value) {
  _set_bit(2);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(value);
}
inline void Cell::set_row_key(const char* value) {
  _set_bit(2);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(value);
}
inline void Cell::set_row_key(const void* value, size_t size) {
  _set_bit(2);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  row_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cell::mutable_row_key() {
  _set_bit(2);
  if (row_key_ == &_default_row_key_) {
    row_key_ = new ::std::string;
  }
  return row_key_;
}

// optional fixed64 version = 4;
inline bool Cell::has_version() const {
  return _has_bit(3);
}
inline void Cell::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 Cell::version() const {
  return version_;
}
inline void Cell::set_version(::google::protobuf::uint64 value) {
  _set_bit(3);
  version_ = value;
}

// optional bytes data = 5;
inline bool Cell::has_data() const {
  return _has_bit(4);
}
inline void Cell::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Cell::data() const {
  return *data_;
}
inline void Cell::set_data(const ::std::string& value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Cell::set_data(const char* value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Cell::set_data(const void* value, size_t size) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cell::mutable_data() {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// OperationResult

// optional uint32 error_code = 1 [default = 0];
inline bool OperationResult::has_error_code() const {
  return _has_bit(0);
}
inline void OperationResult::clear_error_code() {
  error_code_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OperationResult::error_code() const {
  return error_code_;
}
inline void OperationResult::set_error_code(::google::protobuf::uint32 value) {
  _set_bit(0);
  error_code_ = value;
}

// required .bnet.protocol.storage.TableId table_id = 2;
inline bool OperationResult::has_table_id() const {
  return _has_bit(1);
}
inline void OperationResult::clear_table_id() {
  if (table_id_ != NULL) table_id_->::bnet::protocol::storage::TableId::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::TableId& OperationResult::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::bnet::protocol::storage::TableId* OperationResult::mutable_table_id() {
  _set_bit(1);
  if (table_id_ == NULL) table_id_ = new ::bnet::protocol::storage::TableId;
  return table_id_;
}

// repeated .bnet.protocol.storage.Cell data = 3;
inline int OperationResult::data_size() const {
  return data_.size();
}
inline void OperationResult::clear_data() {
  data_.Clear();
}
inline const ::bnet::protocol::storage::Cell& OperationResult::data(int index) const {
  return data_.Get(index);
}
inline ::bnet::protocol::storage::Cell* OperationResult::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::bnet::protocol::storage::Cell* OperationResult::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Cell >&
OperationResult::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Cell >*
OperationResult::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// OpenTableRequest

// optional string schema = 1 [default = "DEFAULT"];
inline bool OpenTableRequest::has_schema() const {
  return _has_bit(0);
}
inline void OpenTableRequest::clear_schema() {
  if (schema_ != &_default_schema_) {
    schema_->assign(_default_schema_);
  }
  _clear_bit(0);
}
inline const ::std::string& OpenTableRequest::schema() const {
  return *schema_;
}
inline void OpenTableRequest::set_schema(const ::std::string& value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void OpenTableRequest::set_schema(const char* value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void OpenTableRequest::set_schema(const char* value, size_t size) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenTableRequest::mutable_schema() {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string(_default_schema_);
  }
  return schema_;
}

// optional .bnet.protocol.storage.Privilege privilege = 2;
inline bool OpenTableRequest::has_privilege() const {
  return _has_bit(1);
}
inline void OpenTableRequest::clear_privilege() {
  if (privilege_ != NULL) privilege_->::bnet::protocol::storage::Privilege::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::Privilege& OpenTableRequest::privilege() const {
  return privilege_ != NULL ? *privilege_ : *default_instance_->privilege_;
}
inline ::bnet::protocol::storage::Privilege* OpenTableRequest::mutable_privilege() {
  _set_bit(1);
  if (privilege_ == NULL) privilege_ = new ::bnet::protocol::storage::Privilege;
  return privilege_;
}

// required .bnet.protocol.storage.TableId table_id = 3;
inline bool OpenTableRequest::has_table_id() const {
  return _has_bit(2);
}
inline void OpenTableRequest::clear_table_id() {
  if (table_id_ != NULL) table_id_->::bnet::protocol::storage::TableId::Clear();
  _clear_bit(2);
}
inline const ::bnet::protocol::storage::TableId& OpenTableRequest::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::bnet::protocol::storage::TableId* OpenTableRequest::mutable_table_id() {
  _set_bit(2);
  if (table_id_ == NULL) table_id_ = new ::bnet::protocol::storage::TableId;
  return table_id_;
}

// optional .bnet.protocol.EntityId agent_id = 4;
inline bool OpenTableRequest::has_agent_id() const {
  return _has_bit(3);
}
inline void OpenTableRequest::clear_agent_id() {
  if (agent_id_ != NULL) agent_id_->::bnet::protocol::EntityId::Clear();
  _clear_bit(3);
}
inline const ::bnet::protocol::EntityId& OpenTableRequest::agent_id() const {
  return agent_id_ != NULL ? *agent_id_ : *default_instance_->agent_id_;
}
inline ::bnet::protocol::EntityId* OpenTableRequest::mutable_agent_id() {
  _set_bit(3);
  if (agent_id_ == NULL) agent_id_ = new ::bnet::protocol::EntityId;
  return agent_id_;
}

// optional string process_name = 5;
inline bool OpenTableRequest::has_process_name() const {
  return _has_bit(4);
}
inline void OpenTableRequest::clear_process_name() {
  if (process_name_ != &_default_process_name_) {
    process_name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& OpenTableRequest::process_name() const {
  return *process_name_;
}
inline void OpenTableRequest::set_process_name(const ::std::string& value) {
  _set_bit(4);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void OpenTableRequest::set_process_name(const char* value) {
  _set_bit(4);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void OpenTableRequest::set_process_name(const char* value, size_t size) {
  _set_bit(4);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenTableRequest::mutable_process_name() {
  _set_bit(4);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}

// -------------------------------------------------------------------

// OpenTableResponse

// -------------------------------------------------------------------

// OpenColumnRequest

// optional string schema = 1 [default = "DEFAULT"];
inline bool OpenColumnRequest::has_schema() const {
  return _has_bit(0);
}
inline void OpenColumnRequest::clear_schema() {
  if (schema_ != &_default_schema_) {
    schema_->assign(_default_schema_);
  }
  _clear_bit(0);
}
inline const ::std::string& OpenColumnRequest::schema() const {
  return *schema_;
}
inline void OpenColumnRequest::set_schema(const ::std::string& value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void OpenColumnRequest::set_schema(const char* value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void OpenColumnRequest::set_schema(const char* value, size_t size) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenColumnRequest::mutable_schema() {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string(_default_schema_);
  }
  return schema_;
}

// optional .bnet.protocol.storage.Privilege privilege = 2;
inline bool OpenColumnRequest::has_privilege() const {
  return _has_bit(1);
}
inline void OpenColumnRequest::clear_privilege() {
  if (privilege_ != NULL) privilege_->::bnet::protocol::storage::Privilege::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::Privilege& OpenColumnRequest::privilege() const {
  return privilege_ != NULL ? *privilege_ : *default_instance_->privilege_;
}
inline ::bnet::protocol::storage::Privilege* OpenColumnRequest::mutable_privilege() {
  _set_bit(1);
  if (privilege_ == NULL) privilege_ = new ::bnet::protocol::storage::Privilege;
  return privilege_;
}

// required .bnet.protocol.storage.TableId table_id = 4;
inline bool OpenColumnRequest::has_table_id() const {
  return _has_bit(2);
}
inline void OpenColumnRequest::clear_table_id() {
  if (table_id_ != NULL) table_id_->::bnet::protocol::storage::TableId::Clear();
  _clear_bit(2);
}
inline const ::bnet::protocol::storage::TableId& OpenColumnRequest::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::bnet::protocol::storage::TableId* OpenColumnRequest::mutable_table_id() {
  _set_bit(2);
  if (table_id_ == NULL) table_id_ = new ::bnet::protocol::storage::TableId;
  return table_id_;
}

// required .bnet.protocol.storage.ColumnId column_id = 5;
inline bool OpenColumnRequest::has_column_id() const {
  return _has_bit(3);
}
inline void OpenColumnRequest::clear_column_id() {
  if (column_id_ != NULL) column_id_->::bnet::protocol::storage::ColumnId::Clear();
  _clear_bit(3);
}
inline const ::bnet::protocol::storage::ColumnId& OpenColumnRequest::column_id() const {
  return column_id_ != NULL ? *column_id_ : *default_instance_->column_id_;
}
inline ::bnet::protocol::storage::ColumnId* OpenColumnRequest::mutable_column_id() {
  _set_bit(3);
  if (column_id_ == NULL) column_id_ = new ::bnet::protocol::storage::ColumnId;
  return column_id_;
}

// optional string proto_type = 6;
inline bool OpenColumnRequest::has_proto_type() const {
  return _has_bit(4);
}
inline void OpenColumnRequest::clear_proto_type() {
  if (proto_type_ != &_default_proto_type_) {
    proto_type_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& OpenColumnRequest::proto_type() const {
  return *proto_type_;
}
inline void OpenColumnRequest::set_proto_type(const ::std::string& value) {
  _set_bit(4);
  if (proto_type_ == &_default_proto_type_) {
    proto_type_ = new ::std::string;
  }
  proto_type_->assign(value);
}
inline void OpenColumnRequest::set_proto_type(const char* value) {
  _set_bit(4);
  if (proto_type_ == &_default_proto_type_) {
    proto_type_ = new ::std::string;
  }
  proto_type_->assign(value);
}
inline void OpenColumnRequest::set_proto_type(const char* value, size_t size) {
  _set_bit(4);
  if (proto_type_ == &_default_proto_type_) {
    proto_type_ = new ::std::string;
  }
  proto_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenColumnRequest::mutable_proto_type() {
  _set_bit(4);
  if (proto_type_ == &_default_proto_type_) {
    proto_type_ = new ::std::string;
  }
  return proto_type_;
}

// optional .bnet.protocol.EntityId agent_id = 7;
inline bool OpenColumnRequest::has_agent_id() const {
  return _has_bit(5);
}
inline void OpenColumnRequest::clear_agent_id() {
  if (agent_id_ != NULL) agent_id_->::bnet::protocol::EntityId::Clear();
  _clear_bit(5);
}
inline const ::bnet::protocol::EntityId& OpenColumnRequest::agent_id() const {
  return agent_id_ != NULL ? *agent_id_ : *default_instance_->agent_id_;
}
inline ::bnet::protocol::EntityId* OpenColumnRequest::mutable_agent_id() {
  _set_bit(5);
  if (agent_id_ == NULL) agent_id_ = new ::bnet::protocol::EntityId;
  return agent_id_;
}

// optional string process_name = 8;
inline bool OpenColumnRequest::has_process_name() const {
  return _has_bit(6);
}
inline void OpenColumnRequest::clear_process_name() {
  if (process_name_ != &_default_process_name_) {
    process_name_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& OpenColumnRequest::process_name() const {
  return *process_name_;
}
inline void OpenColumnRequest::set_process_name(const ::std::string& value) {
  _set_bit(6);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void OpenColumnRequest::set_process_name(const char* value) {
  _set_bit(6);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void OpenColumnRequest::set_process_name(const char* value, size_t size) {
  _set_bit(6);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenColumnRequest::mutable_process_name() {
  _set_bit(6);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}

// -------------------------------------------------------------------

// OpenColumnResponse

// optional bool server_field_ops = 2 [default = false];
inline bool OpenColumnResponse::has_server_field_ops() const {
  return _has_bit(0);
}
inline void OpenColumnResponse::clear_server_field_ops() {
  server_field_ops_ = false;
  _clear_bit(0);
}
inline bool OpenColumnResponse::server_field_ops() const {
  return server_field_ops_;
}
inline void OpenColumnResponse::set_server_field_ops(bool value) {
  _set_bit(0);
  server_field_ops_ = value;
}

// -------------------------------------------------------------------

// ExecuteRequest

// optional string schema = 1 [default = "DEFAULT"];
inline bool ExecuteRequest::has_schema() const {
  return _has_bit(0);
}
inline void ExecuteRequest::clear_schema() {
  if (schema_ != &_default_schema_) {
    schema_->assign(_default_schema_);
  }
  _clear_bit(0);
}
inline const ::std::string& ExecuteRequest::schema() const {
  return *schema_;
}
inline void ExecuteRequest::set_schema(const ::std::string& value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void ExecuteRequest::set_schema(const char* value) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(value);
}
inline void ExecuteRequest::set_schema(const char* value, size_t size) {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string;
  }
  schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteRequest::mutable_schema() {
  _set_bit(0);
  if (schema_ == &_default_schema_) {
    schema_ = new ::std::string(_default_schema_);
  }
  return schema_;
}

// optional .bnet.protocol.storage.Privilege privilege = 2;
inline bool ExecuteRequest::has_privilege() const {
  return _has_bit(1);
}
inline void ExecuteRequest::clear_privilege() {
  if (privilege_ != NULL) privilege_->::bnet::protocol::storage::Privilege::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::storage::Privilege& ExecuteRequest::privilege() const {
  return privilege_ != NULL ? *privilege_ : *default_instance_->privilege_;
}
inline ::bnet::protocol::storage::Privilege* ExecuteRequest::mutable_privilege() {
  _set_bit(1);
  if (privilege_ == NULL) privilege_ = new ::bnet::protocol::storage::Privilege;
  return privilege_;
}

// optional bool read_only = 3 [default = false];
inline bool ExecuteRequest::has_read_only() const {
  return _has_bit(2);
}
inline void ExecuteRequest::clear_read_only() {
  read_only_ = false;
  _clear_bit(2);
}
inline bool ExecuteRequest::read_only() const {
  return read_only_;
}
inline void ExecuteRequest::set_read_only(bool value) {
  _set_bit(2);
  read_only_ = value;
}

// optional bool wants_row_key = 4 [default = false];
inline bool ExecuteRequest::has_wants_row_key() const {
  return _has_bit(3);
}
inline void ExecuteRequest::clear_wants_row_key() {
  wants_row_key_ = false;
  _clear_bit(3);
}
inline bool ExecuteRequest::wants_row_key() const {
  return wants_row_key_;
}
inline void ExecuteRequest::set_wants_row_key(bool value) {
  _set_bit(3);
  wants_row_key_ = value;
}

// optional bool wants_column_name = 5 [default = false];
inline bool ExecuteRequest::has_wants_column_name() const {
  return _has_bit(4);
}
inline void ExecuteRequest::clear_wants_column_name() {
  wants_column_name_ = false;
  _clear_bit(4);
}
inline bool ExecuteRequest::wants_column_name() const {
  return wants_column_name_;
}
inline void ExecuteRequest::set_wants_column_name(bool value) {
  _set_bit(4);
  wants_column_name_ = value;
}

// optional uint32 max_data_size = 6 [default = 16777215];
inline bool ExecuteRequest::has_max_data_size() const {
  return _has_bit(5);
}
inline void ExecuteRequest::clear_max_data_size() {
  max_data_size_ = 16777215u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 ExecuteRequest::max_data_size() const {
  return max_data_size_;
}
inline void ExecuteRequest::set_max_data_size(::google::protobuf::uint32 value) {
  _set_bit(5);
  max_data_size_ = value;
}

// repeated .bnet.protocol.storage.Operation operations = 7;
inline int ExecuteRequest::operations_size() const {
  return operations_.size();
}
inline void ExecuteRequest::clear_operations() {
  operations_.Clear();
}
inline const ::bnet::protocol::storage::Operation& ExecuteRequest::operations(int index) const {
  return operations_.Get(index);
}
inline ::bnet::protocol::storage::Operation* ExecuteRequest::mutable_operations(int index) {
  return operations_.Mutable(index);
}
inline ::bnet::protocol::storage::Operation* ExecuteRequest::add_operations() {
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Operation >&
ExecuteRequest::operations() const {
  return operations_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::Operation >*
ExecuteRequest::mutable_operations() {
  return &operations_;
}

// optional uint32 timeout = 12;
inline bool ExecuteRequest::has_timeout() const {
  return _has_bit(7);
}
inline void ExecuteRequest::clear_timeout() {
  timeout_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 ExecuteRequest::timeout() const {
  return timeout_;
}
inline void ExecuteRequest::set_timeout(::google::protobuf::uint32 value) {
  _set_bit(7);
  timeout_ = value;
}

// optional .bnet.protocol.EntityId agent_id = 9;
inline bool ExecuteRequest::has_agent_id() const {
  return _has_bit(8);
}
inline void ExecuteRequest::clear_agent_id() {
  if (agent_id_ != NULL) agent_id_->::bnet::protocol::EntityId::Clear();
  _clear_bit(8);
}
inline const ::bnet::protocol::EntityId& ExecuteRequest::agent_id() const {
  return agent_id_ != NULL ? *agent_id_ : *default_instance_->agent_id_;
}
inline ::bnet::protocol::EntityId* ExecuteRequest::mutable_agent_id() {
  _set_bit(8);
  if (agent_id_ == NULL) agent_id_ = new ::bnet::protocol::EntityId;
  return agent_id_;
}

// optional string query_name = 10 [default = "NoName"];
inline bool ExecuteRequest::has_query_name() const {
  return _has_bit(9);
}
inline void ExecuteRequest::clear_query_name() {
  if (query_name_ != &_default_query_name_) {
    query_name_->assign(_default_query_name_);
  }
  _clear_bit(9);
}
inline const ::std::string& ExecuteRequest::query_name() const {
  return *query_name_;
}
inline void ExecuteRequest::set_query_name(const ::std::string& value) {
  _set_bit(9);
  if (query_name_ == &_default_query_name_) {
    query_name_ = new ::std::string;
  }
  query_name_->assign(value);
}
inline void ExecuteRequest::set_query_name(const char* value) {
  _set_bit(9);
  if (query_name_ == &_default_query_name_) {
    query_name_ = new ::std::string;
  }
  query_name_->assign(value);
}
inline void ExecuteRequest::set_query_name(const char* value, size_t size) {
  _set_bit(9);
  if (query_name_ == &_default_query_name_) {
    query_name_ = new ::std::string;
  }
  query_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteRequest::mutable_query_name() {
  _set_bit(9);
  if (query_name_ == &_default_query_name_) {
    query_name_ = new ::std::string(_default_query_name_);
  }
  return query_name_;
}

// optional string process_name = 11;
inline bool ExecuteRequest::has_process_name() const {
  return _has_bit(10);
}
inline void ExecuteRequest::clear_process_name() {
  if (process_name_ != &_default_process_name_) {
    process_name_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& ExecuteRequest::process_name() const {
  return *process_name_;
}
inline void ExecuteRequest::set_process_name(const ::std::string& value) {
  _set_bit(10);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void ExecuteRequest::set_process_name(const char* value) {
  _set_bit(10);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void ExecuteRequest::set_process_name(const char* value, size_t size) {
  _set_bit(10);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteRequest::mutable_process_name() {
  _set_bit(10);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}

// -------------------------------------------------------------------

// ExecuteResponse

// optional uint32 error_code = 1 [default = 0];
inline bool ExecuteResponse::has_error_code() const {
  return _has_bit(0);
}
inline void ExecuteResponse::clear_error_code() {
  error_code_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ExecuteResponse::error_code() const {
  return error_code_;
}
inline void ExecuteResponse::set_error_code(::google::protobuf::uint32 value) {
  _set_bit(0);
  error_code_ = value;
}

// repeated .bnet.protocol.storage.OperationResult results = 2;
inline int ExecuteResponse::results_size() const {
  return results_.size();
}
inline void ExecuteResponse::clear_results() {
  results_.Clear();
}
inline const ::bnet::protocol::storage::OperationResult& ExecuteResponse::results(int index) const {
  return results_.Get(index);
}
inline ::bnet::protocol::storage::OperationResult* ExecuteResponse::mutable_results(int index) {
  return results_.Mutable(index);
}
inline ::bnet::protocol::storage::OperationResult* ExecuteResponse::add_results() {
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::OperationResult >&
ExecuteResponse::results() const {
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::storage::OperationResult >*
ExecuteResponse::mutable_results() {
  return &results_;
}

// optional string error_message = 3;
inline bool ExecuteResponse::has_error_message() const {
  return _has_bit(2);
}
inline void ExecuteResponse::clear_error_message() {
  if (error_message_ != &_default_error_message_) {
    error_message_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ExecuteResponse::error_message() const {
  return *error_message_;
}
inline void ExecuteResponse::set_error_message(const ::std::string& value) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ExecuteResponse::set_error_message(const char* value) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ExecuteResponse::set_error_message(const char* value, size_t size) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteResponse::mutable_error_message() {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace storage
}  // namespace protocol
}  // namespace bnet

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bnet::protocol::storage::Privilege_Permission>() {
  return ::bnet::protocol::storage::Privilege_Permission_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bnet::protocol::storage::ScanOperation_Op>() {
  return ::bnet::protocol::storage::ScanOperation_Op_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bnet::protocol::storage::Command_Op>() {
  return ::bnet::protocol::storage::Command_Op_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bnet::protocol::storage::Command_Cond>() {
  return ::bnet::protocol::storage::Command_Cond_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED
